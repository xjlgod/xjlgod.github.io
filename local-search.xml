<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TDD项目实践（一）</title>
    <link href="/2023/08/13/tdd/tdd-one/"/>
    <url>/2023/08/13/tdd/tdd-one/</url>
    
    <content type="html"><![CDATA[<h1 id="TDD项目实践（一）"><a href="#TDD项目实践（一）" class="headerlink" title="TDD项目实践（一）"></a>TDD项目实践（一）</h1><h1 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h1><p>学习原因：自己在开发过程中，一般都是先写总体架构模块，再写模块细节，最后写测试。但发现这样的开发方式有个问题，那就是最后自己在写测试时，总有一种惰性思维，觉得自己流程已经写好且能跑了，应该没有什么错了。写的测试也会根据自己所谓的“正确”思路进行展开，造成一些错误没有注意到。因此学习了TDD（Test-Driven Development，TDD），虽然这是一门很老的开发设计方式，但也被称之为最具效能的一种开发方式。</p><p>使用资料：<a href="https://time.geekbang.org/column/intro/100109401?tab=catalog">徐昊 · TDD项目实战70讲_重构_测试驱动开发_TDD_单元测试_徐昊_徐八叉_伦敦学派_经典学派_Kent Beck_Clean Code_重构到模式-极客时间</a><br>总的来说，这个课程偏实战，目前只学了第一个项目，还在学第二个项目。老师真的对代码那种精益求精的态度，还有“出神入化”ide a适用技巧，跟着做一下还是能学到不少的。但有时老师的思维有点太快了，还是有点跟不上。</p><p>个人相关repo：<br><a href="https://github.com/xjlgod/geektime-tdd-learn">GitHub - xjlgod&#x2F;geektime-tdd-learn: 徐昊TDD项目实战 代码实现</a></p><h1 id="TDD流程"><a href="#TDD流程" class="headerlink" title="TDD流程"></a>TDD流程</h1><p>验证测试与定位测试，贯穿了整个软件构造的过程。测试构成了整个开发流程的骨架，功能开发可以看作填充在测试与测试之间的血肉。这就是测试驱动开发的核心逻辑：以测试作为切入点，可以提纲挈领地帮助我们把握整个研发的过程。<br><img src="https://static001.geekbang.org/resource/image/a5/9c/a5a74d26cf9581064420d81cff7da89c.jpg?wh=2284x1285" alt="image.png"><br>TDD的完整流程可以分为以下几步：</p><ul><li>理解需求，把需求分为一系列的功能点。</li><li>根据功能点进行进一步上下文的划分，称之为功能上下文。</li><li>实现每个功能上下午包含的任务项，首先编写测试，并实现为了通过测试的代码，不断重复此过程，重构代码。<ul><li>红：编写一个失败的小测试，甚至可以是无法编译的测试；</li><li>绿：让这个测试快速通过，甚至不惜犯下任何罪恶；</li><li>重构：消除上一步中产生的所有重复（坏味道）。</li></ul></li></ul><p>在课程中，老师提出了一套任务分解法，将任务列表作为 TDD 的核心要素。</p><ul><li>大致构思软件被使用的方式，把握对外接口的方向；</li><li>大致构思功能的实现方式，划分所需的组件（Component）以及组件间的关系（所谓的架构）。当然，如果没思路，也可以不划分；</li><li>根据需求的功能描述拆分功能点，功能点要考虑正确路径（Happy Path）和边界条件（Sad Path）；</li><li>依照组件以及组件间的关系，将功能拆分到对应组件；</li><li>针对拆分的结果编写测试，进入红 &#x2F; 绿 &#x2F; 重构循环。那么 TDD 的整体工作流程如下图所示：</li></ul><p><img src="https://static001.geekbang.org/resource/image/17/e4/17482a8f6fb89d85d0c9974414fd7fe4.jpg?wh=2283x1286" alt="image.png"></p><h1 id="TDD中的测试方式"><a href="#TDD中的测试方式" class="headerlink" title="TDD中的测试方式"></a>TDD中的测试方式</h1><p>状态验证是指在与待测系统交互后，通过比对测试上下文与待测系统的状态变化，判断待测系统是否满足需求的验证方式。状态验证是一种黑盒验证，它将测试上下文与待测系统当作一个整体。当待测系统不存在内部状态，而通过作用于依赖组件（Depended On Component）达成功能的时候，我们会从依赖组件中获取状态，以验证待测系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>        calculator.add(<span class="hljs-number">5</span>);<br>        assertEquals(<span class="hljs-number">5</span>, calculator.getResult());<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtract</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>        calculator.subtract(<span class="hljs-number">3</span>);<br>        assertEquals(-<span class="hljs-number">3</span>, calculator.getResult());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>行为验证是指通过待测系统与依赖组件（Depended On Component）的交互，来判断待测系统是否满足需求的验证方式。行为验证背后的逻辑是，状态的改变是由交互引起的。如果所有的交互都正确，那么就可以推断最终的状态也不会错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.mockito.Mockito.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddBehavior</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> mock(Calculator.class);<br>        calculator.add(<span class="hljs-number">5</span>);<br>        verify(calculator).add(<span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtractBehavior</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> mock(Calculator.class);<br>        calculator.subtract(<span class="hljs-number">3</span>);<br>        verify(calculator).subtract(<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>在 TDD 社区中，行为验证主要是为了降低测试成本。</strong> 状态验证是将测试上下文与待测系统当作一个整体的黑盒验证，而行为验证就是将它们看作分离组件的白盒验证。它的逻辑是通过测试功能是如何实现的，来推断结果是否正确。换句话说，行为验证本身并不能验证功能是否正确，而只能验证功能是否按照某种方式实现。如果按照某种方式实现，那么就可以推测出功能是正确的。这与 TDD 的核心逻辑就冲突了。在 TDD 的红 &#x2F; 绿 &#x2F; 重构中，重构要求在功能不变的前提下，改变实现方式。 <strong>而对于行为验证而言，实现方式改变就是功能改变</strong> 。因而重构就无法进行！需要重写！也就是说，<strong>行为验证会阻碍 TDD 的进行，应该使用状态验证。</strong><br>值得一提的是，TDD 中的测试不是行业中所谓的“单元测试”，而是 <strong>指能提供快速反馈的低成本的研发测试，也是针对不同粒度单元的功能测试</strong> 。我们要从发现问题和定位问题的角度出发，去理解和思考每一个测试的功效。</p><h1 id="TDD的极限"><a href="#TDD的极限" class="headerlink" title="TDD的极限"></a>TDD的极限</h1><p>让 TDD 丧失驱动力最简单的办法，就是指明某个单元内的实现细节。比如，使用冒泡法对数组进行排序。因为从功能角度来说，冒泡法还是快排序，是没有差别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">should_sort_by_bubble_sort</span><span class="hljs-params">()</span> &#123;<br>  assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, bubbleSort(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">should_sort_by_bubble_sort</span><span class="hljs-params">()</span> &#123;<br>  assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, quickSort(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们需要在测试中体现不同排序算法的差异，以驱动不同的实现，那么就需要改用行为验证。测试驱动开发的主要关注点在于功能在单元（模块）间的分配，而对于模块内怎么实现，需要你有自己的想法。</p><h1 id="TDD中的重构"><a href="#TDD中的重构" class="headerlink" title="TDD中的重构"></a>TDD中的重构</h1><p>TDD 是一种架构技术，它能通过测试与重构，驱动单元的划分以及功能的归属，因而是一种更为落地的架构软件的方式。<br>从功能测试出发，逐步完成软件开发，通过红 &#x2F; 绿 &#x2F; 重构循环中的重构，而不是预先设计（Upfront Design），完成功能的前提下慢慢演进出新的架构，因而也称演进式设计（Evlutionary Design）。通过重构到模式演进式地获得架构，是一种实效主义编码架构风格（Pragmatic Coding Architect）。</p><h1 id="TDD的不同驱动方式"><a href="#TDD的不同驱动方式" class="headerlink" title="TDD的不同驱动方式"></a>TDD的不同驱动方式</h1><p>如果架构愿景不清晰， <strong>那么“最晚尽责时刻”让我们不必花费时间进行空对空的讨论，可以尽早开始实现功能，再通过重构从可工作的软件（Working Software）中提取架构。</strong> 这种方式也被称作 TDD 的经典学派（Classic School）或芝加哥学派（Chicago School）。<br>伦敦学派的做法是这样的：</p><ul><li>按照功能需求与架构愿景划分对象的角色和职责；</li><li>根据角色与职责，明确对象之间的交互；</li><li>按照调用栈（Call Stack）的顺序，自外向内依次实现不同的对象；</li><li>在实现的过程中，依照交互关系，使用测试替身替换所有与被实现对象直接关联的对象；</li><li>直到所有对象全部都实现完成。</li></ul><p>经典学派的做法是这样的：</p><ul><li>经典学派强调功能优先，设计 &#x2F; 架构后置，通过重构进行演进式设计。</li><li>而“伦敦学派”并不排斥预先存在的设计，更强调如何通过测试替身，将注意力集中到功能上下文中的某个对象上。然后在测试的驱动下，按部就班地完成功能开发。</li></ul><p>如果一开始就有了很好的架构规划，可以采用伦敦学派的驱动方式。</p><h1 id="TDD的工程优势"><a href="#TDD的工程优势" class="headerlink" title="TDD的工程优势"></a>TDD的工程优势</h1><p>使用 TDD 开发软件对人的要求，与其他所有软件工程方法对人的要求是一样的：理解需求，明白架构。但是 TDD 提供了这样几点在工程管理上的优势。</p><ul><li>第一，理解需求等于可以针对功能点写出测试。换句话说，写不出测试就是不理解需求。不理解需求就不要开发。在不理解需求的前提下开发功能点，只能带来负的进度。从工程管理角度上看，“判断一个人是否理解了需求”的成本极高。</li><li>第二，不写测试，除了不会写测试之外，就是没理解需求。没理解需求就去写测试，那就是瞎干，瞎干不如不干。如果整个团队都写不出测试，那么说明这个需求无法通过可管控的工程化方式交付。</li><li>第三，所有软件从业人士都认为架构是重要的，但却很少有人理解架构究竟是如何发挥作用的。架构并不是停留在纸面上的框图，而是约定了构成软件系统的组件，以及组件之间的交互方式。也就是说，架构是组件职责划分的依据以及组件的交互模式。 <strong>TDD 则可以通过功能上下文以及任务项拆分的情况，判断成员是否认同并理解了架构。</strong> 如果团队已经形成了架构共识，那么对于相同的功能点，团队中所有成员拆分出的功能上下文应该也相同。因而，从工程管理的角度，TDD 降低了“判断团队是否对架构达成了共识”的成本：看功能上下文拆分就行。</li><li>第四，架构愿景很难在一开始就想得尽善尽美，随着需求发展，总会出现以当前架构愿景不容易实现的需求。如果硬拗进当前架构，就会出现不当的职责划分和别扭的组件交互，这只会加速架构的腐化。而“发现当前架构愿景不容易实现的需求”成本极高。 <strong>TDD 则可以通过功能上下文以及任务项拆分的情况，判断架构是否能够实现当前需求。</strong> 如果无法拆分出合理的功能上下文和任务项，那么这个需求，就是当前架构愿景不易实现的需求。因而，从工程管理的角度，TDD 降低了“发现当前架构愿景不容易实现的需求”的成本：看功能上下文拆分就行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>TDD(测试驱动设计)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD(测试驱动设计)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql中的父事务与子事务</title>
    <link href="/2023/07/13/mysql/transaction/"/>
    <url>/2023/07/13/mysql/transaction/</url>
    
    <content type="html"><![CDATA[<h1 id="MySql中的父事务与子事务"><a href="#MySql中的父事务与子事务" class="headerlink" title="MySql中的父事务与子事务"></a>MySql中的父事务与子事务</h1><h2 id="事务的范围"><a href="#事务的范围" class="headerlink" title="事务的范围"></a>事务的范围</h2><p>事务的范围指的是事务的开始和结束位置。在MySQL中，事务可以通过以下语句来显式地开始和结束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION; <span class="hljs-comment">-- 开始事务</span><br><br><span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- 提交事务</span><br><br><span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">-- 回滚事务</span><br></code></pre></td></tr></table></figure><p>当在MySQL的一个事务中设置了事务隔离级别，该级别的设置将仅对当前事务有效。事务隔离级别定义了事务对数据的读取和修改的可见性和隔离程度。事务隔离级别可以通过以下语句在MySQL中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL <span class="hljs-operator">&lt;</span>isolation_level<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>其中，**<isolation_level>**可以是以下之一：</p><ul><li><strong>READ UNCOMMITTED</strong>：允许脏读、不可重复读和幻读。</li><li><strong>READ COMMITTED</strong>：禁止脏读，但允许不可重复读和幻读。</li><li><strong>REPEATABLE READ</strong>：禁止脏读和不可重复读，但允许幻读。</li><li><strong>SERIALIZABLE</strong>：禁止脏读、不可重复读和幻读。</li></ul><p>一旦设置了事务隔离级别，该级别将在当前事务中生效，其他并发的事务将继续使用各自的隔离级别。这样可以确保每个事务在进行读取和修改时都遵循指定的隔离级别，从而提供一致的数据视图和隔离性。</p><h2 id="父事务与子事务的传递"><a href="#父事务与子事务的传递" class="headerlink" title="父事务与子事务的传递"></a>父事务与子事务的传递</h2><p>在MySQL中，父事务和子事务之间的传递涉及到保存点（Savepoint）的概念。保存点是在事务中创建的标记，用于标识事务中的一个特定位置。通过保存点，我们可以在事务中实现更细粒度的回滚。<br>父事务可以创建保存点，并在子事务中回滚到保存点。这样，子事务可以恢复到保存点时的状态，包括隔离级别。父事务的隔离级别会被子事务继承，除非子事务显式地设置了自己的隔离级别。注意，并不是所有的数据库都支持保存点技术，如果不支持，通常会新建一个事务执行事务。<br>假设我们有两个表：<strong>Orders</strong>（订单）和 <strong>OrderItems</strong>（订单项）。在一个事务中插入一个订单和相关的订单项，并在插入订单项之后创建一个保存点。然后，启动一个子事务，在子事务中删除刚才插入的订单项，并回滚到保存点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION; <span class="hljs-comment">-- 开始父事务</span><br><br><span class="hljs-comment">-- 在父事务中插入订单和订单项</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Orders (order_id, order_date) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-07-13&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> OrderItems (order_id, item_id, quantity) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">SAVEPOINT</span> my_savepoint; <span class="hljs-comment">-- 创建保存点</span><br><br><span class="hljs-comment">-- 启动子事务</span><br><span class="hljs-keyword">START</span> TRANSACTION; <span class="hljs-comment">-- 开始子事务</span><br><br><span class="hljs-comment">-- 在子事务中删除订单项</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> OrderItems <span class="hljs-keyword">WHERE</span> order_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> my_savepoint; <span class="hljs-comment">-- 回滚到保存点</span><br><br><span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- 提交子事务</span><br><br><span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- 提交父事务</span><br></code></pre></td></tr></table></figure><p>在上述示例中，父事务设置了隔离级别为 <strong>REPEATABLE READ</strong>，而子事务没有显式设置隔离级别，因此继承了父事务的隔离级别。通过回滚到保存点，子事务恢复到保存点时的隔离级别，即 <strong>REPEATABLE READ</strong>。因此，删除操作在回滚后被撤销，订单项保留在数据库中。</p><h2 id="Spring中的事务传播行为"><a href="#Spring中的事务传播行为" class="headerlink" title="Spring中的事务传播行为"></a>Spring中的事务传播行为</h2><p>事务传播行为定义了事务在方法调用链中的传播方式。Spring提供了多种事务传播行为选项来实现父事务与子事务的传播。如REQUIRED、REQUIRES_NEW、NESTED等。不同的传播行为对应不同的事务行为，能够满足各种业务需求。在Spring中，事务传播行为通过AOP和动态代理实现。Spring会在方法调用前后织入事务管理的逻辑，确保事务的正确传播和管理。（这里建议去看其他专门写Spring中的事务传播行为的博客）。<br>然而，由于Spring的事务传播行为通过AOP和动态代理实现，有一个常见的问题是自调用方法无法进行事务传递。即当一个方法内部自调用另一个方法时，实际上是在同一个类的实例中进行方法调用，而不是通过代理对象。因此，事务管理的拦截器无法拦截自调用方法，事务传播行为无法被应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyService self;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 事务传播行为将生效</span><br>        <span class="hljs-comment">// ...</span><br><br>        self.doSomethingElse(); <span class="hljs-comment">// 自调用方法，事务传播行为无效，无法代理</span><br><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingElse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个方法无法进行事务传递</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，doSomething()方法是一个事务方法，它调用了自身的doSomethingElse()方法。由于自调用无法进行事务传递，doSomethingElse()方法的事务传播行为将无效。<br>为了解决这个问题，有两种方式：</p><ol><li>将doSomethingElse()方法提取到一个独立的Bean中，并通过依赖注入的方式进行调用。这样，doSomethingElse()方法将通过代理对象进行调用，事务传播行为将得到正确应用。</li><li>将doSomethingElse()中加入从Spring容器中直接取出代理Bean的操作代码，这样会对Spring Api造成强依赖。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用父事务与子事务时，需了解其原理。我们在日常开发中通常是直接使用第三方框架来调用这些事务，如Spring。</p>]]></content>
    
    
    <categories>
      
      <category>MySql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySql</tag>
      
      <tag>Spring</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码整洁之道 学习笔记</title>
    <link href="/2023/07/05/software/code-clean/"/>
    <url>/2023/07/05/software/code-clean/</url>
    
    <content type="html"><![CDATA[<h1 id="代码整洁之道-学习笔记"><a href="#代码整洁之道-学习笔记" class="headerlink" title="代码整洁之道 学习笔记"></a>代码整洁之道 学习笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>阅读背景：</strong><br>代码整洁之道是我在蚂蚁集团实习时（后悔最后没留那里正式入职hh，相信命运的安排吧！），组长推荐给我阅读的。我看网上不少工作了几年的大佬都会推荐这本书给自己的新人读。代码作为我们程序员最直观的工作体现，我认为写的整洁、可读性强，且易于维护还是很重要的。</p><p><strong>推荐理由：</strong><br>一个人在知晓了最好的实践方法时，会比不知晓的情况下去下意识的模仿这些最佳实践而写出的代码好的多。另外这本书所写的也不要认为都是对的，要去思考，软件工程没有永远的银弹。这本书中的一些理念在实际工作中可能也会被他人所不接受的，一切以自身的环境去考虑是否适用。</p><p><strong>概述：</strong><br>《代码整洁之道》是软件开发领域的经典之作，作者Robert C. Martin（通常被称为Uncle Bob）是软件工程界的知名人物。该书的核心理念是通过编写整洁、可读性强且易于维护的代码来提高软件质量。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>以下内容按照整本书的目录进行浓缩总结而成，本书还是值得一看的，下面只是浓缩了一些要注意的很重要的理念。</p><h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><ul><li>编写整洁代码的价值在于提高可读性、可维护性和可扩展性。</li><li>简洁性是整洁代码的核心，通过简化代码逻辑、减少重复和保持代码简单性，可以提高代码质量。</li><li>可读性是指代码易于被理解和阅读。良好的命名、适当的注释和清晰的代码结构是实现可读性的关键。</li><li>可维护性意味着代码易于修改和维护。通过遵循设计原则、拆分函数和类的责任以及提取可复用的代码，可以增强代码的可维护性。</li><li><strong>保持代码整洁</strong>：每次签入时，代码都比签出时简洁。</li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>使用有意义和描述性的命名可以使代码更易读、理解和维护。</li><li>好的命名应该能够清晰地传达变量、函数和类的用途和含义。</li><li>避免使用模糊的名称或缩写，而要选择具有明确含义的名称。</li><li>保持一致的命名风格有助于代码的统一性和可读性（可以看看组里大家的规范）。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数应该短小、专注于单一任务，遵循单一职责原则（SRP），例如一个函数的for循环不能超过两行。</li><li>短小的函数更易于理解和维护，有助于提高代码的可读性和可测试性。特别是在一个大型函数下，各个小型函数的良好使用能让你更好的知道运行流程。</li><li>提取函数是一种常见的重构技术，可以将复杂的代码块拆分成更小、更易于理解的函数，ide的重构功能好好用起来。</li><li>使用有意义的函数名和参数命名可以提高函数的可读性。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释应该解释代码的意图、背后的原因或特定的设计决策，而不是重复代码本身。</li><li>避免过度注释，因为过多的注释可能会导致混乱和维护问题。</li><li>编写自解释的代码是更好的选择，通过良好的命名和清晰的代码结构来提高代码的可读性。</li><li>注释应该准确、简明扼要，并与代码保持同步。</li><li>有些老系统的注释可能是误导，不要全信。</li><li>不要为了注释而注释（我之前一个组就是这样，一个变量上再写这个变量的名字，好的一个注释完成了）。</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>代码的格式化和排版对于可读性和一致性非常重要（参照大家的格式，不要自己创建）。</li><li>使用一致的缩进和空格风格，例如使用制表符或空格来缩进代码块。</li><li>适当地使用空行和空格来增强代码的可读性和分组逻辑。</li><li>避免过长的行和复杂的表达式，适当地换行和拆分可以提高代码的可读性。</li></ul><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ul><li>对象和数据结构具有不同的设计原则和用途。对象：把数据隐藏于抽象后，提供函数调用；数据结构：暴露数据，没有有意义的函数提供。</li><li>面向对象设计注重封装性和抽象性，隐藏内部实现细节，通过方法提供对数据的操作。</li><li>数据结构更加简单直接，通常是将数据暴露给外部，而不提供行为方法。</li><li>理解对象（例如领域业务）和数据结构（例如数据传输对象）之间的差异有助于选择适当的设计模式和实现方式。</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>错误处理是软件开发中必不可少的一部分，良好的错误处理可以提高代码的可靠性和可维护性。</li><li>明确处理错误并及时通知调用者是一种良好的实践。</li><li>使用异常来处理错误情况，而不是简单地返回错误码或特殊值（当然你可以封装在错误里）。</li><li>提供清晰、准确的错误消息，以便开发人员和用户能够理解错误的原因和解决方法。</li><li>别轻易传递null，很容易出现一些莫名其妙的错误。</li></ul><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><ul><li>边界是系统与外部世界（如数据库、第三方服务）交互的地方。</li><li>定义清晰的边界接口有助于隔离和管理与外部系统的交互（把外部调用给加一层，让系统依赖所加的这层）。</li><li>使用适配器和封装代码来处理边界交互，确保代码的可读性和可维护性。</li><li>避免直接依赖外部系统，使用抽象层将其封装起来。</li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul><li>单元测试是保证代码质量的重要手段。</li><li>编写可靠、独立和可重复执行的单元测试有助于发现和修复问题。</li><li>使用测试驱动开发（TDD）方法（TDD建议好好学习），先编写测试用例，再编写代码以满足测试用例的需求。</li><li>单元测试应该简洁、清晰明了，覆盖各种情况和边界条件。</li><li>每个测试一个断言。</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>类是面向对象编程的核心，它们应该具有清晰的目的和职责。</li><li>遵循单一职责原则（SRP），每个类应该只负责一项任务。</li><li>封装数据和隐藏实现细节，使用适当的访问修饰符来控制对类成员的访问。</li><li>通过合理的类设计来提高代码的可读性和可维护性。</li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li>系统设计涉及模块划分、依赖关系和组织架构等方面。</li><li>良好的系统设计应该有清晰的模块划分和合理的依赖关系，以便于理解和维护。</li><li>使用适当的设计模式和架构原则来构建系统，例如依赖注入、领域驱动设计等。</li><li>避免循环依赖和紧耦合的模块关系，通过松耦合和抽象化来增强系统的可扩展性。</li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><ul><li>迭进式开发是持续交付和持续改进的关键实践。</li><li>迭进开发应该注重代码质量，避免技术债务的累积。</li><li>频繁进行重构和代码优化，保持代码的整洁性和可维护性。</li><li>使用持续集成和自动化测试来确保代码的质量和稳定性。</li><li>简单设计规则：运行所有测试、不可重复、表达程序员的意图、尽可能减少类和方法数量。</li></ul><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ul><li>理解并发编程模型和相关概念，如锁、信号量、线程池等。</li><li>避免共享可变状态，使用线程安全的数据结构和同步机制。</li><li>编写干净、安全的并发代码，避免出现竞态条件和死锁等问题。</li><li>把并发代码与非并发代码分开，便于调试。</li><li>并非代码的测试尽量全面。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>本书最后给出了三章实践，但是由于排版问题和翻译问题（也可能是我自己的理解能力问题）。其实这三章看着比较吃力，大家看后也可以和我交流下。我认为掌握了书中之前的理念，自己在工作学习中一直坚持，肯定会有不一样的收获。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>书是好书，一些理念很实用，推荐一看。里面的案例分析如果读着不清晰，可以尝试找些其他的资料看看。</p>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World, 博客问世</title>
    <link href="/2023/06/28/hello-world/"/>
    <url>/2023/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="博客模板"><a href="#博客模板" class="headerlink" title="博客模板"></a>博客模板</h1><p>该博客使用<a href="https://hexo.fluid-dev.com/docs/">Fluid</a>模板搭建而成，<br>它是一款 Material Design 风格的 Hexo 博客主题。</p><h1 id="博客repo地址"><a href="#博客repo地址" class="headerlink" title="博客repo地址"></a>博客repo地址</h1><p>点击<a href="https://github.com/xjlgod/xjlgod.github.io">博客repo地址</a>可查看该<br>博客相关的所有源代码。</p><p>最后欢迎大家在该博客下一起交流与讨论！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
